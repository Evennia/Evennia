"""
Pathfinder

Contrib - Johnny 2018

A batteries-included abstraction for in-MUD navigation.

Builds a queryable "map" (directional graph) of all of your game's Rooms and 
Exits, even accounting for one-way travel.

Requires the `networkx` library, not included with Evennia, but only a
`pip install networkx` away.

---

DIRECTIONS:
Pathfinder provides a function to get directions (the shortest path) between any
two locations. For example, an injured NPC could request directions to the local 
hospital from the bottom of a dungeon (['up', 'east', 'up', 'north', 'north', 
'east']), or you can easily implement things like autonomous mobs or vehicles.

Mob AI can also take advantage of it to get the shortest path to their next
intended victim-- just provide the mob's location and the target's location.

LINE OF SIGHT:
Pathfinder also provides an easy way to look across multiple unobstructed rooms 
in a given direction. For example, if the next five rooms allow you to travel
'east', you can get references to all five rooms with a single 'look east' query. 
But if there is no eastern exit in the adjacent room, you won't see beyond it.

This only works if your exits are keyed by a consistent generic direction, as 
opposed to unique (high-cardinality) destination names. (i.e. 'left', 'east', 
'up', 'in', n', 'w' will work, but 'apothecary', 'dungeon', 'subway' or the like
will not). This will also not work as expected if your exits implement twisted
passage logic, where exiting a room to the east requires re-entry from the north.

That the line-of-sight query looks at a precached "map" instead of having to 
calculate the same result per user upon request makes this a much more efficient 
solution, and scales better at longer distances (like open prairies or deserts).

EXPORT:
You can export the "map" generated by the Pathfinder in JSON Graph format. 
External libraries can allow you to visualize or render your "map" in ways beyond
what a terminal can support.

Usage:

The Pathfinder class can be used like any Python object, but it is expensive to
construct and maintain, so you don't want to create it repeatedly, nor do you
want multiple instances of it floating around. These "maps" are very memory-hungry
as they grow.

Using this class directly is really only appropriate for testing and experimenta-
tion. For general usage, you'll want to use the helper Script included to create
the "map" and keep it updated.

    from evennia.contrib.pathfinding.pathfinder import Pathfinder

    # Instantiation
    pathfinder = Pathfinder()
    
    # Refresh the Pathfinder to add/remove new/old rooms and exits
    pathfinder.update()
    
    # Get directions from one character to another
    room1 = char1.location
    room2 = char2.location
    pathfinder.get_directions(room1, room2)
    >> ['down', 'east', 'down', 'north', 'down']
    
    # Get line of sight between consecutive rooms, no further than 3 rooms away
    # 'look east'
    pathfinder.get_line_of_sight(room1, 'east', 3)
    >> [<DefaultRoom: Railcar #0>, <DefaultRoom: Railcar #1>, <DefaultRoom: Railcar #2>]

"""

from evennia import DefaultExit as Exit, DefaultRoom as Room
from evennia.locks.lockhandler import LockHandler
from itertools import chain
from networkx.readwrite import json_graph
import networkx as nx
import json

# Define a dummy class to do lock checks against
class Edge(object):
    def __init__(self, edge, source_graph):
        self.src = edge[0]
        self.dst = edge[1]
        
        attrs = source_graph[self.src][self.dst]
        self.key = attrs.get('key', attrs.get('direction'))
        self.lock_storage = attrs['locks_str']
        self.locks = LockHandler(self)

class Pathfinder(nx.DiGraph):
    """
    Creates a directional graph of your entire network of rooms and exits.
    """
    # Arbitrary delimiter used to create unique keys to use as nodes.
    # Should not be set it to anything that could conceivably be part of a room
    # name since it will interfere with parsing.
    delimiter = '[(:@_@:)]'
    
    def __init__(self, *args, **kwargs):
        """
        Creates the graph and initializes it.
        
        Kwargs:
            queryset (QuerySet, optional): QuerySet of Room objects to be 
                included in the graph
                
        """
        self.queryset = kwargs.pop('queryset', None)
        super(Pathfinder, self).__init__(*args, **kwargs)
        
    def get_key(self, room):
        """
        Creates unique keys for use as nodes in the graph.

        Args:
            room (Room): Room object needing a key.
            
        Returns:
            key (str): Unique key identifying the node.
        
        """
        return self.delimiter.join([room.db_key, str(room.id)])
        
    def get_queryset(self):
        """
        Get all the Room objects to be included in this graph.
        
        Returns:
            objs (generator): Any iterable generator of Room objects you
                wish to be part of the graph.
            
        """
        if self.queryset: 
            return (x for x in self.queryset)
        else:
            return Room.objects.all().iterator()
    
    def update(self):
        """
        Updates the graph, adding or deleting any new/old Rooms and Exits.

        Returns:
            self (Pathfinder): This object.

        """
        # Get all Room objects in play
        all_rooms = self.get_queryset()
        
        for src in all_rooms:
            # Create node for src room
            src_key = self.get_key(src)
            
            # Check if node exists
            try: self[src_key]
            except: self.add_node(src_key, key=src.db_key, id=src.id, type='room', locks_str=str(src.locks))
            
            for exit in src.exits:
                # Get destination room
                dst = exit.destination
                
                # Create a node for dst room
                dst_key = self.get_key(dst)
                try: self[dst_key]
                except: self.add_node(dst_key, key=dst.db_key, id=dst.id, type='room', locks_str=str(dst.locks))
                
                # Create an edge representing the exit
                self.add_edge(src_key, dst_key, direction=exit.db_key, id=exit.id, type='exit', locks_str=str(exit.locks))
                
        return self
                
    def get_path(self, source, dest):
        """
        Computes shortest path between source and dest objects.
        
        This is primarily an internal function; it is recommended that you use 
        one of the other helper methods to perform any queries.
        
        Args:
            source (Room): Origin Room object.
            dest (Room): Destination Room object.

        Returns:
            path (list): List of node tokens comprising the path from the source
                to the detination.

        """
        # Get keys for source and dest
        src_key = self.get_key(source)
        dst_key = self.get_key(dest)
        
        # Get the shortest path
        try: path = nx.shortest_path(self, source=src_key, target=dst_key)
        except nx.NetworkXNoPath: path = []
        except nx.NodeNotFound: path = []
        
        return path
        
    def get_usable_path(self, source, dest, caller):
        """
        Returns the shortest possible usable path by the caller.
        """
        # Get keys for source and dest
        src_key = self.get_key(source)
        dst_key = self.get_key(dest)
                
        # Get all edges that are traversable by the caller
        user_graph = nx.DiGraph()
        for edge in chain(self.out_edges(), self.in_edges()):
            edge_obj = Edge(edge, self)
            
            # Perform the check
            result = edge_obj.locks.check(caller, 'traverse')
        
            # If passes, add to user_graph
            if result:
                user_graph.add_edge(edge_obj.src, edge_obj.dst, direction=edge_obj.key)
            
        # Now that we have a graph of all possible ways the object can get to
        # the destination, calculate the shortest path
        try: path = nx.shortest_path(user_graph, source=src_key, target=dst_key)
        except nx.NetworkXNoPath: path = []
        except nx.NodeNotFound: path = []
        
        return path
        
    def get_directions(self, source, dest, caller=None):
        """
        Computes shortest path between source and dest objects.
        
        Returns a list of the directional commands you would need to execute to 
        move from your starting location to your desired destination.
        
        Args:
            source (Room): Origin Room object.
            dest (Room): Destination Room object.
            caller (DefaultObject): Object needing directions.

        Returns:
            steps (list): List of directional commands.

        """
        # Account for object permissions during traversal if possible
        if caller:
            path = self.get_usable_path(source, dest, caller)
            
        # Get a straight point-A-to-B path
        else:
            path = self.get_path(source, dest)
            
        steps = []
        
        # Get the edge attributes for each hop
        edge_ids = zip(path[0:], path[1:])
        for src, dst in edge_ids:
            direction = self[src][dst]['direction']
            steps.append(direction)
        
        return steps
        
    def get_line_of_sight(self, source, direction, caller=None, distance=10, **kwargs):
        """
        Returns a list of Room objects accessible by following the given
        direction from the given origin. The list terminates when a Room does
        not offer continued travel in that direction.
        
        Mob AI can take advantage of this by getting the list of rooms in a
        given direction and examining the contents of each, looking for victims
        at range.
        
        This is also useful if implementing something like a sniper rifle, which
        could let a player see the occupants of any number of unobstructed rooms 
        ahead of them.
        
        Args:
            source (Room): Origin Room object.
            direction (str): Any implemented direction a character can travel
                from their source location.
            caller (DefaultObject): The object to calculate line-of-sight for.
            distance (int): Max number of Rooms to span. Uses 10 as a sane
                default, though you should define to suit your geospatial needs.
                
        Kwargs:
            ordered (bool): Whether you want results sorted in order of distance. 
                The default is True, but False makes queries more efficient.

        Returns:
            path (list): List of directional commands needed to go from point A
                to point B.

        """
        bucket = []
        ordered = kwargs.get('ordered', True)
        counter = distance
        
        # Get keys for source
        src_key = self.get_key(source)
        
        # Recursively crawl as far in the given direction as we can go
        def follow(src_key, direction, counter, bucket):
            # If key is already in bucket, the path loops back onto itself--
            # bust out now to avoid an infinite recursion.
            # Also exit if we've reached max distance.
            if (src_key in bucket) or (counter <= 0):
                counter = -1
                return
            
            # Add this key to the path
            bucket.append(src_key)
            counter -= 1
            
            # This should realistically only ever find a single out_edge since 
            # you can't have multiple exits with the same name
            edges = ((src, dst, self[src][dst]['locks_str']) for src, dst in self.out_edges(src_key) if self[src][dst]['direction'] == direction)
            for src, dst, locks_str in edges:
                can_view = True
                
                # Block view if the caller was provided and they do not have
                # view rights to the room
                if caller:
                    # Create an edge object
                    edge_obj = Edge((src, dst), self)
                    
                    # Check locks
                    can_view = edge_obj.locks.check(caller, 'traverse')
                    
                if can_view:
                    follow(dst, direction, counter, bucket)
                else: 
                    # If the player can't see into a room, it doesn't make any
                    # sense that they would see past it either. Abort.
                    counter == -1
                
                if counter <= 0: return
            
        follow(src_key, direction, counter, bucket)
        
        ids = [x.split(self.delimiter)[1] for x in bucket]
        if ordered:
            # If ordered, query all objects serially
            return [Room.objects.get(id=x) for x in ids]
        else:
            # If unordered, we can query all objects in bulk (it's faster)
            return list(Room.objects.filter(id__in=ids))

    def export_png(self, filename='map.png'):
        """
        Draws the graph and its connections as a PNG.
        
        Requires matplotlib, and the result lacks aesthetics. The export_json()
        method is more flexible for external rendering; this is more here for
        debugging.
        
        Args:
            filename (str): Filename for the output file.

        """
        try:
            import matplotlib
            matplotlib.use('Agg')
            import matplotlib.pyplot as plt
        except ImportError:
            msg = 'Pathfinder draw_map() feature requires matplotlib.'
            logger.log_err(msg)
            print(msg)
            return None
            
        pos = nx.spring_layout(self, scale=5, k=0.5,iterations=20)
        nx.draw(self, pos, with_labels=True)
        
        plt.savefig(filename)
        
    def export_json(self, **kwargs):
        """
        Exports graph data in JSON Graph format so you can do fun things like
        render it in d3.js or other libraries, such as for display on the website.
        
        https://github.com/jsongraph/json-graph-specification
        
        Kwargs:
            any (any): Passed directly to node_link_data function. Can be used
                to modify key names of output.
        
        Returns:
            data (str): Serialized JSON string comprising the graph data.
            
        """
        data = json_graph.node_link_data(self, **kwargs)
        return json.dumps(data, indent=4)