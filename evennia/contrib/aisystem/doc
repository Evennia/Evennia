

leaf nodes - conditions, actions


composite nodes:
sequence - iterate through successes, stop at first fail, return fail; else return fail
also include probability / priority versions
probability selector - randomly pick one child node based on the nodes' weights
priority selector - iterate through failures, stop at first success, return success; else return fail
	On critical error, selector backtracks with same error.
parallel - success/failure policies, master behavior whose success / failure decides this node's success / failure result

probabilistic selector and sequence nodes skip going for nodes they have already gone over.


decorator nodes:
inverter - success becomes failure, failure becomes success, does not change running or error
succeeder, failer
repeater - if state is success or failure, repeats the child until maximum # of repetitions is met, then returns success. Otherwise, returns state.
repeat until fail, repeat until succeed
limiter - prohibits the child from being called more than n times
max_time - if the child does not complete execution before max_time is reached, stop the child and return failure




services

decorators:
	filters - limit # of times, provide timer, temporarily deactivate behavior, restrict # of behaviors running simultaneously
	managers - decorate entire subtrees, store information referring to them
	control modifiers - force a return status
	meta operations - debug, logging


allocators - first-come-first-served, priorities, compromise; scope (single-actor, group, global); number of concurrent behaviors; interrupts



Termination status:
* success
* failure
* error
* running










Architecture:

AI tree model - stores an individual AI tree that can be loaded by scripts. Can be created by attaching individual nodes or entire trees
	* new AI tree: comes with root node
	* need a means to assign an entry in the data dictionary / list for each node, via a hash

AI blackboard model - stores a reference to a single AI tree that it goes through with each iteration of the script, along with a list of active nodes and a data dictionary
	* need a means to unload the old data dict and load the new one when nodes are added / removed




Leaf nodes should have an 


